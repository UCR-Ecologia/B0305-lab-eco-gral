---
subtitle: "B0305 -- Lab Eco Gral"
title: "<font style='font-size:1em;'>Diseño experimental, (pseudo)replicación, poder estadístico</font>"
author: Prof. T Nakov
institute: 'Escuela de Biologia, Universidad de Costa Rica'
date: 01 August 2025
date-meta: 01 August 2025
date-format: "DD MMM YYYY"
toc: true
toc-depth: 1
toc-title: "Que vamos a ver:"
center-title-slide: false
from: markdown+emoji
format:
  revealjs: 
    fig-responsive: true
    theme: simple
    slide-number: true
    mouse-wheel: false
    preview-links: auto
    incremental: false
    logo: /figures/icons/course_favicon.png
    css: /css/styles_slides.css
    footer: 'B0305 -- Lab Eco Gral'
execute:
  echo: true
  cache: false
---

## Diseño experimental

---

## Por qué importa el diseño experimental

- Ecología = sistemas complejos y variables  
- Mal diseño → conclusiones inválidas, esfuerzo desperdiciado  
- Buen diseño → inferencia más sólida, capacidad de generalizar  

---

::: {.columns}
::: {.column}
::: {.fragment}
- **Diseño experimental**  
  - El investigador manipula tratamientos (ej. sombreado vs sin sombreado).  
  - Inferencia más fuerte sobre causa-efecto. Requiere control de factores confusores.  
:::
:::
::: {.column}
::: {.fragment}
- **Diseño natural**  
  - El investigador aprovecha la variación natural (ej. arroyos soleados vs sombreados).  
  - No hay asignación verdadera de tratamientos   
:::

:::
::: 

::: {.fragment}
::: {.callout-note title="¡Ojo!"}
Incluso sin manipulación, es necesaria una definición clara de *unidades experimentales* y *replicación*.
:::
:::

---

## Diseño Factorial

- **Definición:** Se prueban todas las combinaciones de factores.  
- Ejemplo: Dos factores → luz (alta/baja) × nutrientes (altos/bajos)  
  - Tratamientos = 2 × 2 = 4 combinaciones  
- Ventaja: puede detectar **efectos de interacción** (cómo se combinan los factores).  
<!-- - Limitación: crece rápidamente con el número de factores.  -->

---

```{r}
#| label: fig-factorial
#| fig-cap: "2×2 factorial design schematic: Light × Nutrients."
#| fig-width: 10
#| fig-height: 6
#| echo: false
library(ggplot2)

# Data for a 2x2 factorial tile schematic
df_fact <- expand.grid(Light = c("Low Light","High Light"),
                       Nutrients = c("Low Nutrients","High Nutrients"))
df_fact$Treatment <- paste(df_fact$Light, df_fact$Nutrients, sep="\n")

# Plot
ggplot(df_fact, aes(x = Nutrients, y = Light)) +
  geom_tile(fill = "steelblue", color = "white", linewidth = 0.6) +
  geom_text(aes(label = Treatment), fontface = "bold", size = 8) +
  scale_y_discrete(limits = rev) +
  coord_equal() +
  labs(x = NULL, y = NULL) +
  theme_minimal(base_size = 20) +
  theme(panel.grid = element_blank(),
        axis.text.x = element_text(margin = margin(t = 6)),
        axis.text.y = element_text(margin = margin(r = 6)))
```

---

## Bloques

- **Definición:** Agrupar unidades experimentales en bloques que comparten condiciones similares.  
- Ejemplo: La fertilidad del suelo varía a través de un campo → cada bloque contiene todos los tratamientos.  
- Propósito: controlar fuentes conocidas de variación.  
- Análisis: el bloque se incluye como factor en el modelo (aleatorio o fijo).  

**Idea clave:** Los bloques reducen el *ruido* de la heterogeneidad.  

---

```{r}
#| label: fig-blocking
#| fig-cap: "Randomized complete block design: each block contains all treatments."
#| fig-width: 10
#| fig-height: 6
#| echo: false
library(dplyr)
library(tidyr)
set.seed(42)

treatments <- c("Control","Light","Nutrients","Light+Nutrients")
blocks <- paste("Block", 1:3)

# Create a layout with randomized treatment order within each block
df_block <- expand.grid(Block = blocks, Plot = 1:length(treatments)) %>%
  group_by(Block) %>%
  mutate(Treatment = sample(treatments, size = n(), replace = FALSE)) %>%
  # mutate(Treatment = treatments) %>%
  ungroup() %>%
  mutate(Block = factor(Block, levels = blocks),
         PlotPos = Plot)

# Plot as rows = blocks, columns = plots
ggplot(df_block, aes(x = PlotPos, y = Block, fill = Treatment, label = Treatment)) +
  geom_tile(color = "white", linewidth = 0.6, height = 0.8) +
  geom_text(size = 6, fontface = "bold", color = "black") +
  scale_x_continuous(breaks = 1:4, labels = paste("Plot", 1:4)) +
  scale_fill_brewer(palette = "Set2") +
  labs(x = NULL, y = NULL) +
  theme_minimal(base_size = 25) +
  theme(panel.grid = element_blank(),
        legend.position = "bottom",
        axis.text.x = element_text(margin = margin(t = 6)),
        axis.text.y = element_text(margin = margin(r = 6)))
```

---

## Aleatorización

- **Definición:** Asignación aleatoria de tratamientos a unidades experimentales.  
- Propósito: evita sesgo sistemático.  
<!-- - Asegura que los efectos del tratamiento no se confundan con variables ocultas.   -->
- Puede ser completa o restringida (dentro de bloques).  

**Ejemplo:** Asignar aleatoriamente sombreado vs control a estanques, no solo "primera mitad sombreada, segunda mitad control."

---

```{r}
#| label: fig-randomization
#| fig-cap: "Randomized assignment of treatments on a field grid (within blocks)."
#| fig-width: 10
#| fig-height: 10
#| echo: false
library(dplyr)
library(ggplot2)
set.seed(123)

# Grid layout (e.g., 4 columns × 6 rows), with 3 horizontal blocks
n_cols <- 4
n_rows <- 6
treats <- c("Control","Light","Nutrients","Light+Nutrients")

grid <- expand.grid(col = 1:n_cols, row = 1:n_rows) %>%
  mutate(Block = cut(row, breaks = c(0,2,4,6), labels = c("Block 1","Block 2","Block 3")))

# Randomize treatments within each block with near-equal counts
assign_block <- function(n, levels) {
  rep_len(sample(levels), n) |> sample(n)  # shuffle
}

df_rand <- grid %>%
  group_by(Block) %>%
  mutate(Treatment = assign_block(n(), treats)) %>%
  ungroup()

# Plot grid with block facets (or block borders)
ggplot(df_rand, aes(x = col, y = row, fill = Treatment, label = substr(Treatment,1,1))) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(size = 8, fontface = "bold", color = "black") +
  scale_y_reverse(breaks = 1:n_rows) +
  scale_x_continuous(breaks = 1:n_cols) +
  scale_fill_brewer(palette = "Set2") +
  labs(x = "Column", y = "Row") +
  theme_minimal(base_size = 25) +
  theme(panel.grid = element_blank(),
        legend.position = "bottom") +
  facet_wrap(~ Block, ncol = 1, scales = "free_y")
```

---

## Mensajes claves {.dark-slide}

- **Diseño factorial**: probar múltiples factores y sus interacciones.  
- **Bloques**: controlar variación agrupando unidades similares.  
- **Aleatorización**: protegerse contra sesgo.  

<!-- **Mejor práctica:** combinar los tres cuando sea posible → experimentos robustos e interpretables.   -->

---

## Replicación y pseudoeplicación

---


## Conceptos fundamentales

::: {.fragment}
- **Tratamiento**: Lo que se manipula  
- **Unidad Experimental**: La unidad más pequeña que puede recibir independientemente un tratamiento  
- **Replicación**: Múltiples unidades experimentales independientes por tratamiento  
:::

::: {.fragment}
::: {.callout-note title="¡Ojo!"}
Replicación = unidades experimentales, *no* muestras.
:::
:::

---

## Replicación

- Propósito: estimar variabilidad, probar hipótesis confiablemente  
- Tipos:  
  - *Replicación verdadera*: unidades independientes (20 plantas)  
  - *Replicación técnica*: medidas repetidas de la misma unidad (20 hojas de 1 planta)  
- Regla práctica: Replicación = número de unidades independientes

---

![Replicación verdadera vs pseudo replicación](figures/replication.png)

---

![Replicación verdadera vs pseudo replicación](figures/replication2.jpeg)

<!-- ---

## Ejemplos

- Medir 20 hojas de 1 planta → **n = ?**  
- Medir 1 hoja de cada una de 20 plantas → **n = ?**
- Medir crecimiento de algas después de adición de nutrientes 5 días seguidos → **n = ?**
- Contar líquenes en 4 lados de 1 árbol → **n = ?** -->


---

<!-- ## Tipos de Pseudoreplicación

- **Simple**: 1 unidad experimental por tratamiento medida múltiples veces 
- **Temporal**: medidas repetidas en el tiempo usadas como réplicas  

--- -->

## Evitando la pseudoreplicación

- Múltiples unidades independientes por tratamiento  
- Asignación aleatoria de tratamientos  
- Bloques para controlar la variación  
- Modelos jerárquicos / mixtos para datos anidados  

---

## Mensajes clave {.dark-slide}

- Replicación = unidades independientes, **no** medidas repetidas  
- La pseudoreplicación es común pero evitable  
- Reconocer cuando la replicación completa es imposible  

---

## Poder Estadístico: Introducción

::: {.fragment}
- **Poder estadístico** = probabilidad de detectar un efecto si verdaderamente existe  
- Poder = 1 – β  
  - β (Error Tipo II): fallar en rechazar una hipótesis nula cuando esta falsa  
- Meta común: **80% de poder**  
:::

::: {.fragment}
::: {.callout-note title="¡Ojo!"}
Alto poder = buena oportunidad de detectar efectos biológicamente significativos.
:::
:::

---

<!-- ## Por qué importa el análisis de poder

- La ecología a menudo trata con alta variabilidad  
- Muy pocas réplicas → falsos negativos (perder efectos reales)  
- Demasiadas réplicas → tiempo, esfuerzo y recursos desperdiciados  
- El análisis de poder ayuda a equilibrar factibilidad y rigor científico   -->

---

## Componentes del poder

El poder depende de: 

- **Tamaño del efecto**: qué tan grande es la diferencia verdadera  
- **Tamaño de muestra (n)**: número de unidades independientes  
- **Varianza (σ²)**: variabilidad natural en el sistema  
- **Nivel de significancia (α)**: usualmente 0.05  

---

## Poder y varianza: Cómo se conectan

- Recordar: El poder depende del tamaño del efecto, tamaño de muestra, varianza, y α  
- En la práctica, **la varianza (σ²)** está incorporada en el *tamaño del efecto*  

Para una prueba t de dos muestras:  

$$
d = \frac{\text{diferencia de medias}}{\text{desviación estándar}}
$$

---

## Ejemplo: De varianza a poder

Supongamos que probamos sombreado vs sin sombreado en el crecimiento de algas:  

- Diferencia de medias esperada = **20 unidades**  
- Datos piloto: desviación estándar = **25**  
- Nivel de significancia α = 0.05  
- Poder objetivo = 0.80  

$$
d = \frac{20}{25} = 0.8
$$

Pregunta: ¿Cuántos arroyos réplica por tratamiento se necesitan?
---

## Cálculo en R

```{r}
library(pwr)

# Tamaño del efecto a partir de diferencia de medias y DE
d <- 20 / 25   # = 0.8

# Análisis de poder para prueba t de dos muestras
pwr.t.test(d = d, power = 0.8, sig.level = 0.05,
           type = "two.sample")
```

Resultado: ~26 réplicas por grupo necesarias

--- 

## Interpretación

- Con σ = 25, detectar una diferencia de 20 unidades necesita ~26 réplicas por tratamiento.

- Si la variabilidad fuera menor (σ = 10):
    d = 20/10 = 2 → muchas menos réplicas necesarias

- Si la variabilidad fuera mayor (σ = 40):
    d = 20/40 = 0.5 → mucha más replicación necesaria

---

## Mensajes Clave {.dark-slide}

- Planificar el tamaño de muestra antes del experimento  
- ¡La varianza importa! Dicta qué tan grande se ve el efecto relativo al ruido.  
- Siempre tratar de estimar la varianza de estudios piloto o la literatura.  

---

## Bibliografia

Statistics done wrong: https://www.statisticsdonewrong.com/pseudoreplication.html

Marshall, D.J., 2024. Principles of experimental design for ecology and evolution. Ecology Letters, 27(4), p.e14400. [📄 PDF](../../refs/Marshall-2024.pdf)

Gotelli, N. J., & Ellison, A. M. (2004). A primer of ecological statistics (Vol. 1), Capitulo 4. Sunderland: Sinauer Associates. [📄 PDF](../../refs/Gotelli-2004-cap-4.pdf)

Gotelli, N. J., & Ellison, A. M. (2004). A primer of ecological statistics (Vol. 1), Capitulo 6. Sunderland: Sinauer Associates. [📄 PDF](../../refs/Gotelli-2004-cap-6.pdf)

---
